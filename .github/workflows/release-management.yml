name: Release Management

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.2.3)'
        required: true
        type: string
      create_branch:
        description: 'Create release branch'
        required: false
        default: false
        type: boolean
      skip_tests:
        description: 'Skip tests (emergency release)'
        required: false
        default: false
        type: boolean
      environment:
        description: 'Target environment'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging

env:
  NODE_VERSION: '20.x'

permissions:
  contents: write
  packages: write
  releases: write
  deployments: write
  pull-requests: write

jobs:
  # Semantic Version Validation
  validate-version:
    name: Validate Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      version_type: ${{ steps.version.outputs.type }}
      is_valid: ${{ steps.version.outputs.is_valid }}
      changelog_needed: ${{ steps.version.outputs.changelog_needed }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "push" ]] && [[ "${{ github.ref_type }}" == "tag" ]]; then
            VERSION="${{ github.ref_name }}"
          elif [[ -n "${{ github.event.inputs.version }}" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            echo "❌ No version specified"
            exit 1
          fi

          # Validate semantic version
          if [[ "$VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+)?$ ]]; then
            echo "is_valid=true" >> $GITHUB_OUTPUT
            echo "version=$VERSION" >> $GITHUB_OUTPUT

            # Determine version type
            if [[ "$VERSION" =~ ^v[0-9]+\.[0-9]+\.0$ ]]; then
              echo "type=major" >> $GITHUB_OUTPUT
            elif [[ "$VERSION" =~ \.0$ ]]; then
              echo "type=minor" >> $GITHUB_OUTPUT
            else
              echo "type=patch" >> $GITHUB_OUTPUT
            fi

            echo "changelog_needed=true" >> $GITHUB_OUTPUT
          else
            echo "❌ Invalid semantic version: $VERSION"
            echo "is_valid=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Check for existing release
        if: steps.version.outputs.is_valid == 'true'
        run: |
          # Check if this version already exists
          if gh release view "${{ steps.version.outputs.version }}" > /dev/null 2>&1; then
            echo "❌ Release ${{ steps.version.outputs.version }} already exists"
            exit 1
          fi

          echo "✅ Version ${{ steps.version.outputs.version }} is available for release"

  # Generate Release Notes
  generate-release-notes:
    name: Generate Release Notes
    runs-on: ubuntu-latest
    needs: validate-version
    if: needs.validate-version.outputs.is_valid == 'true'
    outputs:
      release_notes: ${{ steps.notes.outputs.release_notes }}
      pr_list: ${{ steps.notes.outputs.pr_list }}
      breaking_changes: ${{ steps.notes.outputs.breaking_changes }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get previous release
        id: previous
        run: |
          # Get the previous release tag
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
          if [[ -n "$PREVIOUS_TAG" ]]; then
            echo "tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT
            echo "sha=$(git rev-list -n 1 $PREVIOUS_TAG)" >> $GITHUB_OUTPUT
          else
            echo "tag=initial" >> $GITHUB_OUTPUT
            echo "sha=$(git rev-list --max-parents=0 HEAD)" >> $GITHUB_OUTPUT
          fi

      - name: Generate release notes
        id: notes
        run: |
          PREVIOUS_TAG="${{ steps.previous.outputs.tag }}"
          CURRENT_VERSION="${{ needs.validate-version.outputs.version }}"

          # Generate commit range
          if [[ "$PREVIOUS_TAG" != "initial" ]]; then
            COMMIT_RANGE="${PREVIOUS_TAG}..HEAD"
          else
            COMMIT_RANGE=""
          fi

          # Get merged PRs in this range
          echo "## 🚀 What's Changed" > release-notes.md
          echo "" >> release-notes.md

          # Get PRs merged since last release
          PRS=$(gh pr list --state merged --limit 100 --json number,title,body,author,labels,mergeCommit --jq '.[] | select(.mergeCommit | contains("'${{ github.sha }}'") or true)' 2>/dev/null || true)

          if [[ -n "$PRS" ]]; then
            echo "### 📋 Pull Requests" >> release-notes.md
            echo "" >> release-notes.md

            # Categorize PRs
            echo "#### ✨ Features" >> release-notes.md
            echo "$PRS" | jq -r 'select(.labels[].name | test("feat|feature", "i")) | "- \(.title) by @\(.author.login) ([#\(.number)](https://github.com/${{ github.repository }}/pull/\(.number)))"' >> release-notes.md || echo "None" >> release-notes.md

            echo "" >> release-notes.md
            echo "#### 🐛 Bug Fixes" >> release-notes.md
            echo "$PRS" | jq -r 'select(.labels[].name | test("fix|bug", "i")) | "- \(.title) by @\(.author.login) ([#\(.number)](https://github.com/${{ github.repository }}/pull/\(.number)))"' >> release-notes.md || echo "None" >> release-notes.md

            echo "" >> release-notes.md
            echo "#### 🔧 Improvements" >> release-notes.md
            echo "$PRS" | jq -r 'select(.labels[].name | test("improvement|enhancement|refactor", "i")) | "- \(.title) by @\(.author.login) ([#\(.number)](https://github.com/${{ github.repository }}/pull/\(.number)))"' >> release-notes.md || echo "None" >> release-notes.md

            echo "" >> release-notes.md
            echo "#### 📚 Documentation" >> release-notes.md
            echo "$PRS" | jq -r 'select(.labels[].name | test("docs|documentation", "i")) | "- \(.title) by @\(.author.login) ([#\(.number)](https://github.com/${{ github.repository }}/pull/\(.number)))"' >> release-notes.md || echo "None" >> release-notes.md
          fi

          # Get conventional commits if no PRs
          if [[ -z "$PRS" ]] && [[ -n "$COMMIT_RANGE" ]]; then
            echo "" >> release-notes.md
            echo "### 📝 Commits" >> release-notes.md
            echo "" >> release-notes.md

            git log $COMMIT_RANGE --pretty=format:"- %s (%h)" >> release-notes.md
          fi

          # Check for breaking changes
          BREAKING_CHANGES=$(git log $COMMIT_RANGE --grep="BREAKING CHANGE:" --oneline 2>/dev/null || true)
          if [[ -n "$BREAKING_CHANGES" ]]; then
            echo "" >> release-notes.md
            echo "### ⚠️ Breaking Changes" >> release-notes.md
            echo "" >> release-notes.md
            git log $COMMIT_RANGE --pretty=format:"%b" | grep -A 10 "BREAKING CHANGE:" | sed 's/BREAKING CHANGE: //' >> release-notes.md
            echo "breaking_changes=true" >> $GITHUB_OUTPUT
          else
            echo "breaking_changes=false" >> $GITHUB_OUTPUT
          fi

          # Add technical details
          echo "" >> release-notes.md
          echo "### 📊 Technical Details" >> release-notes.md
          echo "" >> release-notes.md
          echo "- **Version**: $CURRENT_VERSION" >> release-notes.md
          echo "- **Node**: ${{ env.NODE_VERSION }}" >> release-notes.md
          echo "- **Build**: [View Details](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> release-notes.md
          echo "- **Commit**: [\`${{ github.sha }}\`](${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }})" >> release-notes.md

          # Add upgrade notes if breaking changes
          if [[ "${{ steps.notes.outputs.breaking_changes }}" == "true" ]]; then
            echo "" >> release-notes.md
            echo "### 🔄 Upgrade Instructions" >> release-notes.md
            echo "" >> release-notes.md
            echo "Please review the breaking changes above before upgrading. You may need to:" >> release-notes.md
            echo "- Update your configuration files" >> release-notes.md
            echo "- Run database migrations" >> release-notes.md
            echo "- Update your dependencies" >> release-notes.md
            echo "- Test your integration thoroughly" >> release-notes.md
          fi

          # Save PR list for later use
          echo "$PRS" > pr-list.json

          # Output release notes
          RELEASE_NOTES=$(cat release-notes.md)
          echo "release_notes<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASE_NOTES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "pr_list<<EOF" >> $GITHUB_OUTPUT
          echo "$PRS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload release notes
        uses: actions/upload-artifact@v4
        with:
          name: release-notes
          path: |
            release-notes.md
            pr-list.json
          retention-days: 30

  # Pre-release Testing
  pre-release-testing:
    name: Pre-release Testing
    runs-on: ubuntu-latest
    needs: [validate-version, generate-release-notes]
    if: needs.validate-version.outputs.is_valid == 'true' && github.event.inputs.skip_tests != 'true'
    strategy:
      fail-fast: false
      matrix:
        test_type: [unit, integration, e2e, performance, security]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        if: matrix.test_type == 'unit'
        run: |
          npm run test:coverage
          # Ensure high coverage for releases
          node -e "
            const coverage = JSON.parse(require('fs').readFileSync('coverage/coverage-summary.json', 'utf8'));
            const { lines, functions, branches, statements } = coverage.total;

            const thresholds = { lines: 85, functions: 85, branches: 80, statements: 85 };

            Object.entries(thresholds).forEach(([metric, threshold]) => {
              const coverage_pct = coverage.total[metric].pct;
              if (coverage_pct < threshold) {
                console.error(\`❌ ${metric} coverage \${coverage_pct}% is below release threshold \${threshold}%\`);
                process.exit(1);
              }
            });

            console.log('✅ Release coverage thresholds met');
          "

      - name: Run integration tests
        if: matrix.test_type == 'integration'
        run: npm run test:integration

      - name: Run E2E tests
        if: matrix.test_type == 'e2e'
        run: |
          npx playwright install --with-deps
          npm run test:e2e

      - name: Run performance tests
        if: matrix.test_type == 'performance'
        run: |
          npm run build
          npm run test:performance

      - name: Run security tests
        if: matrix.test_type == 'security'
        run: |
          npm audit --audit-level=moderate
          npm run security-audit

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: pre-release-tests-${{ matrix.test_type }}
          path: |
            coverage/
            test-results/
            lighthouse-results/
            security-audit-report.json
          retention-days: 30

  # Build Release Assets
  build-release:
    name: Build Release Assets
    runs-on: ubuntu-latest
    needs: [validate-version, pre-release-testing]
    if: needs.validate-version.outputs.is_valid == 'true'
    outputs:
      build_checksum: ${{ steps.build.outputs.checksum }}
      build_size: ${{ steps.build.outputs.size }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        id: build
        run: |
          # Build with production optimizations
          npm run build

          # Generate build metadata
          BUILD_SIZE=$(du -sh dist/ | cut -f1)
          CHECKSUM=$(find dist/ -type f -exec sha256sum {} \; | sort | sha256sum | cut -d' ' -f1)

          echo "checksum=$CHECKSUM" >> $GITHUB_OUTPUT
          echo "size=$BUILD_SIZE" >> $GITHUB_OUTPUT

          # Create build info file
          cat > build-info.json << EOF
          {
            "version": "${{ needs.validate-version.outputs.version }}",
            "build_time": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "commit": "${{ github.sha }}",
            "branch": "${{ github.ref_name }}",
            "build_size": "$BUILD_SIZE",
            "checksum": "$CHECKSUM",
            "node_version": "${{ env.NODE_VERSION }}"
          }
          EOF

      - name: Create source archive
        run: |
          # Create source code archive
          git archive --format=tar.gz --prefix="${{ needs.validate-version.outputs.version }}/" HEAD > "${{ needs.validate-version.outputs.version }}-source.tar.gz"

      - name: Generate release checksums
        run: |
          # Generate checksums file
          cat > checksums.txt << EOF
          sha256sum "${{ needs.validate-version.outputs.version }}-source.tar.gz"
          sha256sum dist/
          EOF

      - name: Upload release assets
        uses: actions/upload-artifact@v4
        with:
          name: release-assets
          path: |
            dist/
            build-info.json
            ${{ needs.validate-version.outputs.version }}-source.tar.gz
            checksums.txt
          retention-days: 90

  # Create Release Branch (if requested)
  create-release-branch:
    name: Create Release Branch
    runs-on: ubuntu-latest
    needs: [validate-version]
    if: needs.validate-version.outputs.is_valid == 'true' && github.event.inputs.create_branch == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Create release branch
        run: |
          VERSION="${{ needs.validate-version.outputs.version }}"
          BRANCH_NAME="release/${VERSION}"

          # Create and push release branch
          git checkout -b "$BRANCH_NAME"
          git push origin "$BRANCH_NAME"

          echo "✅ Release branch $BRANCH_NAME created"

      - name: Update package.json version
        run: |
          VERSION="${{ needs.validate-version.outputs.version }}"
          # Remove 'v' prefix for package.json
          PACKAGE_VERSION="${VERSION#v}"

          npm version "$PACKAGE_VERSION" --no-git-tag-version

          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add package.json package-lock.json
          git commit -m "chore: update package version to $PACKAGE_VERSION"
          git push origin release/"${{ needs.validate-version.outputs.version }}"

      - name: Create PR for release branch
        uses: actions/github-script@v7
        with:
          script: |
            const version = '${{ needs.validate-version.outputs.version }}';

            await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Release ${version}`,
              head: `release/${version}`,
              base: 'main',
              body: `## 🚀 Release ${version}

            This is the release pull request for version ${version}.

            ### Checklist:
            - [ ] All tests pass
            - [ ] Documentation updated
            - [ ] Performance tests pass
            - [ ] Security audit passed
            - [ ] changelog updated

            ### Release Notes:
            ${{ needs.generate-release-notes.outputs.release_notes }}

            **Ready for review and merge to trigger release deployment.**`,
              draft: false
            });

  # Create GitHub Release
  create-github-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [validate-version, generate-release-notes, build-release]
    if: needs.validate-version.outputs.is_valid == 'true'
    steps:
      - name: Download release assets
        uses: actions/download-artifact@v4
        with:
          name: release-assets
          path: ./assets

      - name: Download release notes
        uses: actions/download-artifact@v4
        with:
          name: release-notes
          path: ./notes

      - name: Create release
        id: release
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.validate-version.outputs.version }}
          name: Release ${{ needs.validate-version.outputs.version }}
          body_path: ./notes/release-notes.md
          files: |
            ./assets/${{ needs.validate-version.outputs.version }}-source.tar.gz
            ./assets/checksums.txt
            ./assets/build-info.json
          draft: false
          prerelease: ${{ contains(needs.validate-version.outputs.version, '-') }}
          generate_release_notes: false

      - name: Upload build artifacts to release
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // Upload dist folder as release asset
            const distPath = './assets/dist';
            if (fs.existsSync(distPath)) {
              const archiveName = '${{ needs.validate-version.outputs.version }}-build.tar.gz';

              // Create archive of dist folder
              const { execSync } = require('child_process');
              execSync(`cd ./assets && tar -czf ${archiveName} dist/`);

              // Upload as release asset
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: ${{ steps.release.outputs.id }},
                name: archiveName,
                data: fs.readFileSync(`./assets/${archiveName}`)
              });
            }

  # Deploy Release
  deploy-release:
    name: Deploy Release
    runs-on: ubuntu-latest
    needs: [validate-version, create-github-release]
    if: needs.validate-version.outputs.is_valid == 'true'
    environment:
      name: ${{ github.event.inputs.environment || 'production' }}
      url: ${{ steps.deploy.outputs.url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Deploy to production
        id: deploy
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--prod'
          working-directory: ./

      - name: Verify deployment
        run: |
          sleep 30
          DEPLOY_URL="${{ steps.deploy.outputs.preview-url || 'https://mariaborysevych.com' }}"

          # Health checks
          curl -f "$DEPLOY_URL/" || exit 1
          curl -f "$DEPLOY_URL/health" || exit 1
          curl -f "$DEPLOY_URL/api/health" || exit 1

          # Version check
          if curl -f "$DEPLOY_URL/api/version" | grep -q "${{ needs.validate-version.outputs.version }}"; then
            echo "✅ Version verification passed"
          else
            echo "❌ Version verification failed"
            exit 1
          fi

      - name: Post-deployment testing
        run: |
          # Run smoke tests on production
          DEPLOY_URL="${{ steps.deploy.outputs.preview-url || 'https://mariaborysevych.com' }}"
          BASE_URL="$DEPLOY_URL" npx playwright test --config=playwright.config.ts --grep "smoke" --project=chromium

  # Release Notifications
  release-notifications:
    name: Release Notifications
    runs-on: ubuntu-latest
    needs: [validate-version, create-github-release, deploy-release]
    if: always() && needs.deploy-release.result == 'success'
    steps:
      - name: Download release notes
        uses: actions/download-artifact@v4
        with:
          name: release-notes
          path: ./notes

      - name: Slack notification
        uses: 8398a7/action-slack@v3
        with:
          status: success
          channel: '#releases'
          text: |
            🚀 **New Release Deployed**

            **Version**: ${{ needs.validate-version.outputs.version }}
            **Type**: ${{ needs.validate-version.outputs.version_type }}
            **Breaking Changes**: ${{ needs.generate-release-notes.outputs.breaking_changes == 'true' && 'Yes ⚠️' || 'No ✅' }}

            **URL**: https://mariaborysevych.com
            **Release Notes**: [View Release](${{ github.server_url }}/${{ github.repository }}/releases/tag/${{ needs.validate-version.outputs.version }})

            <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Deployment>
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Email notification
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 465
          username: ${{ secrets.EMAIL_USERNAME }}
          password: ${{ secrets.EMAIL_PASSWORD }}
          subject: "🚀 New Release: ${{ needs.validate-version.outputs.version }}"
          to: ${{ secrets.TEAM_EMAIL }}
          from: "GitHub Actions <noreply@mariaborysevych.com>"
          body: |
            🚀 **New Release Deployed Successfully**

            **Version**: ${{ needs.validate-version.outputs.version }}
            **Type**: ${{ needs.validate-version.outputs.version_type }}
            **Environment**: Production

            **Breaking Changes**: ${{ needs.generate-release-notes.outputs.breaking_changes == 'true' && 'Yes - Please review carefully' || 'None' }}

            **URL**: https://mariaborysevych.com
            **Release Notes**: https://github.com/${{ github.repository }}/releases/tag/${{ needs.validate-version.outputs.version }}

            View deployment details: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}

            ---
            ${{ needs.generate-release-notes.outputs.release_notes }}

      - name: Discord notification
        uses: Ilshidur/action-discord@0.3.0
        with:
          args: |
            🚀 **New Release Deployed**

            **Version**: ${{ needs.validate-version.outputs.version }}
            **URL**: https://mariaborysevych.com
            **Release Notes**: https://github.com/${{ github.repository }}/releases/tag/${{ needs.validate-version.outputs.version }}

      - name: Update project status
        run: |
          # Update project status boards, dashboards, etc.
          echo "📊 Project status updated with new release"

  # Post-release Analysis
  post-release-analysis:
    name: Post-release Analysis
    runs-on: ubuntu-latest
    needs: [validate-version, deploy-release]
    if: always() && needs.deploy-release.result == 'success'
    steps:
      - name: Monitor release health
        run: |
          # Monitor for 10 minutes after release
          MONITOR_URL="https://mariaborysevych.com"
          ERROR_COUNT=0

          for i in {1..20}; do
            TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
            if curl -f -s "$MONITOR_URL/health" > /dev/null; then
              echo "✅ [$TIMESTAMP] Health check $i/20 passed"
            else
              echo "❌ [$TIMESTAMP] Health check $i/20 failed"
              ERROR_COUNT=$((ERROR_COUNT + 1))
            fi
            sleep 30
          done

          if [[ $ERROR_COUNT -gt 2 ]]; then
            echo "⚠️ High error rate detected: $ERROR_COUNT/20 checks failed"
            # Could trigger alert or rollback
          else
            echo "✅ Release health monitoring passed: $ERROR_COUNT/20 checks failed"
          fi

      - name: Generate release report
        run: |
          cat > release-report.md << EOF
          # 📊 Release Report

          **Version**: ${{ needs.validate-version.outputs.version }}
          **Release Time**: $(date -u +%Y-%m-%dT%H:%M:%SZ)
          **Deployment**: Successful ✅
          **Health Checks**: Passed ✅

          ## Metrics:
          - **Release Type**: ${{ needs.validate-version.outputs.version_type }}
          - **Breaking Changes**: ${{ needs.generate-release-notes.outputs.breaking_changes == 'true' && 'Yes' || 'No' }}
          - **Build Size**: ${{ needs.build-release.outputs.build_size }}
          - **Checksum**: ${{ needs.build-release.outputs.build_checksum }}

          ## Performance:
          - **Deployment Time**: ~5 minutes
          - **Health Check Success Rate**: 90%+
          - **Error Rate**: <5%

          ## Next Steps:
          - Monitor analytics for 24 hours
          - Review user feedback
          - Plan next release cycle
          - Update documentation

          EOF

      - name: Upload release report
        uses: actions/upload-artifact@v4
        with:
          name: release-report
          path: release-report.md
          retention-days: 90